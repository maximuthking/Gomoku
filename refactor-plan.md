# Gomoku 프로젝트 리팩토링 계획

## 1. 개요

현재 프로젝트는 TypeScript 기반의 모노레포 구조로, 백엔드는 Node.js, Express, Socket.IO, Prisma를 사용하고 프론트엔드는 React를 사용합니다. 코드 분석 결과, 기능은 대부분 구현되어 있으나 안정성, 확장성, 유지보수성을 개선하기 위한 몇 가지 핵심적인 리팩토링이 필요합니다.

본 계획은 주요 문제점을 해결하고 코드 품질을 높이는 데 중점을 둡니다.

## 2. 주요 리팩토링 목표

1.  **상태 관리 개선 (백엔드):** 현재 인메모리(in-memory)로 관리되는 게임 상태(방 목록, 게임 보드 등)를 영속성 있는 데이터베이스 또는 캐시로 이전하여 서버 재시작 시 데이터가 유실되는 치명적인 문제를 해결합니다.
2.  **코드 구조 개선 (백엔드):** 복잡한 로직을 분리하고, 중복 코드를 제거하며, 관심사 분리(SoC) 원칙을 강화하여 코드의 가독성과 유지보수성을 향상시킵니다.
3.  **타입 공유 (모노레포):** 프론트엔드와 백엔드 간에 중복으로 정의된 타입들을 공유 패키지로 분리하여 타입 안정성을 확보하고 중복을 제거합니다.
4.  **에러 처리 중앙화 (백엔드):** 분산된 에러 처리 로직을 중앙화된 미들웨어로 통합하여 일관성을 높이고 코드 복잡도를 줄입니다.

---

## 3. 세부 리팩토링 계획

### 1단계: 백엔드 상태 관리 개선

-   **문제점:** `gameService.ts`와 `socket/index.ts`에서 게임 관련 상태(`rooms`, `gameStates`)가 인메모리 변수로 관리되고 있어, 서버가 재시작되면 모든 게임 데이터가 사라집니다.
-   **해결책:**
    1.  **게임 상태 모델링:** `schema.prisma`에 `Game` 모델과 `Room` 모델을 추가합니다.
        -   `Room`: 방의 상태 (대기중, 게임중) 등
        -   `Game`: 현재 게임 보드 상태(`board`), 현재 턴(`currentPlayer`), 플레이어 정보 등을 포함합니다.
    2.  **로직 수정:** `gameService.ts`와 `socket/index.ts`의 관련 로직을 Prisma를 사용하도록 수정합니다.
        -   방 생성/참여 시 DB에 데이터를 생성/업데이트합니다.
        -   돌을 놓을 때마다 `Game` 테이블의 `board`를 업데이트합니다.
        -   (선택) 실시간 성능이 중요하다면, 상태 저장을 위해 Redis와 같은 인메모리 데이터 스토어를 도입하는 것을 고려할 수 있습니다.

### 2단계: 백엔드 코드 구조 리팩토링

-   **문제점:** `socket/index.ts`의 `placeStone` 이벤트 핸들러가 너무 복잡하고(100줄 이상), 승리/패배/금수 처리 로직이 중복됩니다.
-   **해결책:**
    1.  **`gameService` 역할 강화:** `gameService.ts`에 핵심 게임 로직 함수를 만듭니다.
        -   `makeMove(roomId, userId, row, col)`: 수를 두는 로직 전체를 담당합니다. 이 함수 내에서 유효성 검사, 금수 판정(`ruleService` 호출), 승리 판정, 게임 상태 업데이트, 게임 결과 저장(`saveGameResult`)까지 모두 처리하고, 업데이트된 게임 상태를 반환합니다.
    2.  **`socket/index.ts` 단순화:** 소켓 핸들러는 단순히 `gameService`의 함수를 호출하고, 그 결과를 클라이언트에 전달하는 역할만 하도록 수정합니다.
    3.  **중복 로직 제거:** `gameService.ts`의 `checkWin`과 `checkOverline` 함수를 `checkLine(board, row, col, requiredCount)`와 같이 일반화된 함수로 통합합니다.

### 3단계: 모노레포 타입 공유

-   **문제점:** `patternService.ts`의 `Pattern` 타입, `gameService.ts`의 `Room`, `GameState` 등의 타입이 백엔드에만 정의되어 있어 프론트엔드에서 재정의해야 합니다.
-   **해결책:**
    1.  **`common` 패키지 생성:** 프로젝트 루트에 `packages/common` 또는 `common` 디렉토리를 생성합니다.
    2.  **공유 타입 이동:** 백엔드와 프론트엔드에서 공통으로 사용될 타입 정의(`Pattern`, `Room`, `User`, `GameState` 등)를 `common` 패키지로 이동시킵니다.
    3.  **경로 설정:** `tsconfig.json`의 `paths` 설정을 이용하여 `@gomoku/common`과 같은 별칭으로 공유 패키지를 쉽게 임포트할 수 있도록 설정합니다.

### 4단계: 에러 처리 및 기타 개선

-   **문제점:** 라우트 핸들러마다 `try-catch` 블록이 반복되고, `(req.user as any)`와 같이 타입 단언을 사용하여 타입 안정성이 떨어집니다.
-   **해결책:**
    1.  **중앙 에러 핸들링 미들웨어:** Express의 에러 핸들링 미들웨어를 구현하여 모든 비동기 에러를 한 곳에서 처리하도록 합니다.
    2.  **`Request` 타입 확장:** `express`의 `Request` 인터페이스를 확장하여 `req.user`에 대한 정확한 타입을 정의하고, `as any` 캐스팅을 제거합니다.
    3.  **환경 변수 관리:** `.env.example` 파일을 프로젝트 루트에 추가하여 필요한 환경 변수 목록을 명시합니다.

---

## 4. 예상되는 결과

-   **안정성:** 서버가 재시작되어도 유저와 게임 진행 상황이 유지됩니다.
-   **유지보수성:** 코드가 더 깔끔해지고 역할 분리가 명확해져서 새로운 기능을 추가하거나 버그를 수정하기 쉬워집니다.
-   **확장성:** 상태 관리가 데이터베이스 기반으로 변경되어, 향후 다중 서버 환경으로 확장할 수 있는 기반이 마련됩니다.
-   **개발 효율성:** 타입 공유를 통해 프론트엔드와 백엔드 간의 데이터 모델을 쉽게 동기화할 수 있습니다.
