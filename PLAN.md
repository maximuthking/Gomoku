# 2D 전통 게임 플랫폼 개발 계획 (PostgreSQL 기반)

## 1. 프로젝트 개요

React와 TypeScript를 활용하여 웹 기반의 **2D 전통 게임 플랫폼**을 개발합니다. 첫 번째 게임으로 **오목**을 구현하고, 추후 **알까기** 등 다른 게임을 쉽게 추가할 수 있는 확장 가능한 구조로 설계합니다. **PostgreSQL** 데이터베이스를 사용하여 유저 정보와 게임 데이터를 체계적으로 관리하고, 구글 계정 로그인을 지원합니다.

## 2. 제안하는 기술 스택

* **프론트엔드:**
    * **프레임워크:** React
    * **언어:** TypeScript
    * **2D 렌더링:** CSS/SVG, (선택) HTML5 Canvas
* **백엔드:**
    * **서버 프레임워크:** Node.js, Express.js
    * **데이터베이스:** **PostgreSQL**
    * **ORM (Object-Relational Mapping):** **Prisma** 또는 TypeORM (DB 작업을 편리하게 해주는 도구)
    * **인증:** **Passport.js** (구글 소셜 로그인 구현용)
    * **실시간 통신:** Socket.IO
* **확장용 기술:**
    * **2D 물리 엔진:** Matter.js (추후 알까기 개발용)

## 3. 핵심 기능

* **구글 계정 기반 로그인 및 유저 관리:**
    * Passport.js를 이용한 간편한 구글 계정 로그인.
    * 로그인 시 유저 정보를 PostgreSQL DB에 저장 및 관리.
* **상세 유저 통계 관리:**
    * **기본 전적:** 유저별/게임별 총 전적, 승률, 승/패 횟수 관리.
    * **게임별 세부 통계:**
        * **플레이 횟수:** 오목, 알까기 등 게임별 총 플레이 횟수.
        * **오목 통계:** 평균 게임 길이(수), 흑돌/백돌을 잡았을 때의 승률.
    * **라이벌 통계:** 특정 상대와의 전적을 별도로 조회하는 기능.
    * 프로필 페이지에서 자신의 통계 확인 기능.
* **게임 로비 및 방 관리:**
    * 플레이할 게임 선택(오목, 알까기 등) 기능.
    * 게임방 생성, 참여, 목록 조회 기능.
* **실시간 멀티플레이어 게임:**
    * Socket.IO를 통한 실시간 게임 상태 동기화.
    * **방 내 실시간 채팅 기능.**
* **게스트 플레이:**
    * 별도 로그인 없이 임시 닉네임으로 게임을 플레이할 수 있는 기능.
    * 게스트 유저의 게임 결과는 전적에 기록되지 않음.

## 4. UI/UX 디자인 구상

### 4.1. 메인 로비 화면
**컨셉: "대청마루에 앉아 바깥 풍경을 보는 듯한" 편안하고 정갈한 공간**

* **레이아웃:** 상/하 분할
    * **상단 '섬' 구역 (작은 레이아웃):** 나무 현판 컨셉. 유저 프로필과 `방 만들기`, `빠른 시작` 등 핵심 버튼 배치.
    * **하단 메인 구역 (넓은 레이아웃):** 넓은 마루 컨셉. `오목`, `알까기` 등 게임 선택 탭과 선택된 게임의 방 목록 표시.

### 4.2. 게임 화면
**컨셉: "벗과 함께 조용한 툇마루에서 대국을 두는 듯한" 집중의 공간**

* **레이아웃:** 3분할 (중앙을 넓게)
    * **왼쪽 구역 (정보):** 내 정보(상), 상대 정보(중), 채팅창(하) 배치. 현재 턴인 플레이어에게 하이라이트 효과 적용.
    * **중앙 구역 (게임판):** 화면 대부분을 차지하는 게임 공간. 나무 소반 질감의 배경.
    * **오른쪽 구역 (기록 및 제어):** 수순 기록과 `항복`, `무승부 제안` 등 제어 버튼 배치.

### 4.3. 사운드 및 애니메이션 효과
**컨셉: 과하지 않으면서도 정갈한 시청각적 경험으로 몰입감 극대화**

* **사운드 효과:**
    * **배경 음악:** 로비에서는 평화로운 국악기 연주곡, 게임 중에는 집중을 위한 자연의 소리(ASMR)나 음악 없음.
    * **효과음:** 오직 **'돌 놓는 소리'** 효과음만 사용하여, 불필요한 사운드를 배제하고 깔끔하고 고급스러운 느낌을 유지.
* **애니메이션 효과:**
    * **UI 애니메이션:** 화면 전환(미닫이문 효과), 버튼 호버(먹물 번짐 효과) 등 부드러운 전환 효과.
    * **게임 애니메이션:** 돌을 놓을 때 부드럽게 내려앉는 효과, 승리 시 붓으로 선을 긋는 듯한 연출, 차례 표시(반딧불 효과) 등 절제되고 미려한 효과 적용.

## 5. 개발 단계

### 단계 1: 환경 구성 및 DB 스키마 설계
* 프론트엔드(React) 및 백엔드(Node.js/Express) 프로젝트 환경을 구성합니다.
* **PostgreSQL 데이터베이스 스키마를 설계합니다.**
    * `users`: 유저 정보 (구글 ID, 닉네임, 프로필 이미지 등)
    * `game_records`: 게임 결과 (승자, 패자, 게임 종류, **총 수순**, **흑돌 플레이어 ID**, 일시 등)
    * `user_stats`: 유저별 통계 (게임별 총 플레이 횟수, 승/패, 흑/백 승리 횟수, 총 플레이 수 등)
* Prisma를 사용하여 설계한 스키마를 기반으로 모델을 생성합니다.

### 단계 2: 백엔드 API 서버 및 인증 시스템 구축
* Express.js를 사용하여 기본적인 백엔드 API 서버 구조를 만듭니다.
* **Passport.js**를 연동하여 **구글 OAuth 2.0 기반의 로그인 및 회원가입** 로직을 구현합니다.
* 로그인 성공 시, 유저 정보를 DB에 저장하고 세션 또는 JWT(JSON Web Token)를 발급하여 인증을 관리합니다.
* 유저 프로필 및 통계 정보를 조회하는 API 엔드포인트를 개발합니다.

### 단계 3: 실시간 통신(웹소켓) 서버 구축
* 구축된 Express 서버에 Socket.IO를 통합합니다.
* 유저 연결/해제, 게임방 입장/퇴장 등 실시간 통신을 위한 기본 이벤트를 처리하는 로직을 구현합니다.

### 단계 4: 로비 및 게임방 기능 구현
* 프론트엔드에서 로비 UI를 구현하고, 백엔드 API와 연동하여 게임방 생성/참여/목록 조회를 구현합니다.
* 게임방에 입장하면 해당 방의 웹소켓 네임스페이스에 연결되도록 로직을 구성합니다.
* 방 내 실시간 채팅 기능을 구현합니다.

### 단계 5: 오목 게임 모듈 개발 및 통합
* 프론트엔드에서 오목판, 돌 등 오목 게임 컴포넌트를 개발합니다.
* 돌을 놓는 등의 게임 액션을 Socket.IO를 통해 백엔드 서버로 전송합니다.
* 서버는 전달받은 액션의 유효성(렌주 룰 검사 등)을 검증하고, 결과를 방 안의 모든 클라이언트에게 브로드캐스트하여 게임 상태를 동기화합니다.

### 단계 6: 게임 결과 처리 및 통계 기능 구현
* 게임이 종료되면, 서버는 게임 결과(**총 수순, 흑/백 플레이어 정보 포함**)를 `game_records` 테이블에 기록하고, 관련된 유저들의 `user_stats`(**게임별 플레이 횟수, 흑/백 승리 횟수 등 상세 정보**)를 업데이트합니다.
* 프론트엔드에서 유저 프로필 페이지를 만들고, API를 통해 전적과 승률 등 상세 데이터를 받아와 표시합니다.

### 단계 7: 최종 테스트, 개선 및 배포
* UI/UX를 개선하고 전반적인 사용자 경험을 다듬습니다.
* 프론트엔드와 백엔드를 각각 서버에 배포하고 연동합니다.

## 6. 검증

* **인증 및 세션:** 구글 로그인이 정상적으로 동작하고, 로그인 상태가 안전하게 유지되는지 테스트합니다.
* **데이터 정확성:** 게임 결과가 DB에 정확하게 기록되고, 이를 바탕으로 계산된 **상세 통계**가 올바른지 검증합니다.
* **오목 게임 로직:** 돌 놓기, 턴 전환, 렌주 룰의 금수 및 승리 조건이 정확하게 작동하는지 검증합니다.
* **실시간 동기화:** 여러 클라이언트에서 동시에 접속하여 게임이 지연이나 오류 없이 정상적으로 동기화되는지 테스트합니다.
* **확장성:** 추후 알까기 게임을 추가할 때, 기존 백엔드 API와 DB 구조를 크게 변경하지 않고도 확장 가능한지 구조를 검토합니다.